SCRIPT  /home/romain/.vim/pack/bundle/start/python-mode/autoload/pymode/rope.vim
Sourced 1 time
Total time:   0.021694
 Self time:   0.021691

count  total (s)   self (s)
                            " Python-mode Rope support
                            "
    1              0.021286 PymodePython from pymode import rope
                            
    1   0.000024   0.000021 call pymode#tools#loclist#init()
                            
                            
    1              0.000002 fun! pymode#rope#completions(findstart, base)
                                PymodePython rope.completions()
                            endfunction
                            
    1              0.000001 fun! pymode#rope#complete(dot)
                                if pumvisible()
                                    return "\<C-n>"
                                end
                                if a:dot
                                    PymodePython rope.complete(True)
                                else
                                    PymodePython rope.complete()
                                end
                                return pumvisible() ? "\<C-p>\<Down>" : ""
                            endfunction
                            
    1              0.000001 fun! pymode#rope#complete_on_dot() "{{{
                                if !exists("*synstack")
                                    return ""
                                end
                                for group in map(synstack(line('.'), col('.') - 1), 'synIDattr(v:val, "name")')
                                    for name in ['pythonString', 'pythonComment', 'pythonNumber', 'pythonDocstring']
                                        if group == name
                                            return "" 
                                        endif
                                    endfor
                                endfor
                                if g:pymode_rope_autoimport_import_after_complete
                                    PymodePython rope.complete_check()
                                endif
                                return pymode#rope#complete(1)
                            endfunction "}}}
                            
    1              0.000001 fun! pymode#rope#goto_definition()
                                PymodePython rope.goto()
                            endfunction
                            
                            
    1              0.000001 fun! pymode#rope#organize_imports()
                                if !pymode#save()
                                    return 0
                                endif
                                call pymode#wide_message('Organize imports ... ')
                                PymodePython rope.organize_imports()
                            endfunction
                            
                            
    1              0.000001 fun! pymode#rope#find_it()
                                let loclist = g:PymodeLocList.current()
                                let loclist._title = "Occurrences"
                                call pymode#wide_message('Finding Occurrences ...')
                                PymodePython rope.find_it()
                                call loclist.show()
                            endfunction
                            
                            
    1              0.000001 fun! pymode#rope#show_doc()
                                let l:output = []
                            
                                PymodePython rope.show_doc()
                            
                                if !empty(l:output)
                                    call pymode#tempbuffer_open('__doc____rope__')
                                    call append(0, l:output)
                                    setlocal nomodifiable
                                    setlocal nomodified
                                    setlocal filetype=rst
                                    wincmd p
                                end
                            endfunction
                            
                            
    1              0.000001 fun! pymode#rope#regenerate() "{{{
                                call pymode#wide_message('Regenerate Rope cache ... ')
                                PymodePython rope.regenerate()
                            endfunction "}}}
                            
                            
    1              0.000001 fun! pymode#rope#new(...) "{{{
                                PymodePython rope.new()
                            endfunction "}}}
                            
                            
    1              0.000001 fun! pymode#rope#rename() "{{{
                                if !pymode#save()
                                    return 0
                                endif
                                PymodePython rope.RenameRefactoring().run()
                            endfunction "}}}
                            
    1              0.000001 fun! pymode#rope#rename_module() "{{{
                                if !pymode#save()
                                    return 0
                                endif
                                PymodePython rope.RenameRefactoring(True).run()
                            endfunction "}}}
                            
    1              0.000001 fun! pymode#rope#extract_method() range "{{{
                                if !pymode#save()
                                    return 0
                                endif
                                PymodePython rope.ExtractMethodRefactoring().run()
                            endfunction "}}}
                            
    1              0.000002 fun! pymode#rope#extract_variable() range "{{{
                                if !pymode#save()
                                    return 0
                                endif
                                PymodePython rope.ExtractVariableRefactoring().run()
                            endfunction "}}}
                            
    1              0.000001 fun! pymode#rope#undo() "{{{
                                PymodePython rope.undo()
                            endfunction "}}}
                            
    1              0.000001 fun! pymode#rope#redo() "{{{
                                PymodePython rope.redo()
                            endfunction "}}}
                            
    1              0.000001 fun! pymode#rope#inline() "{{{
                                if !pymode#save()
                                    return 0
                                endif
                                PymodePython rope.InlineRefactoring().run()
                            endfunction "}}}
                            
    1              0.000001 fun! pymode#rope#move() "{{{
                                if !pymode#save()
                                    return 0
                                endif
                                PymodePython rope.MoveRefactoring().run()
                            endfunction "}}}
                            
    1              0.000001 fun! pymode#rope#signature() "{{{
                                if !pymode#save()
                                    return 0
                                endif
                                PymodePython rope.ChangeSignatureRefactoring().run()
                            endfunction "}}}
                            
    1              0.000002 fun! pymode#rope#use_function() "{{{
                                if !pymode#save()
                                    return 0
                                endif
                                PymodePython rope.UseFunctionRefactoring().run()
                            endfunction "}}}
                            
    1              0.000001 fun! pymode#rope#module_to_package() "{{{
                                if !pymode#save()
                                    return 0
                                endif
                                PymodePython rope.ModuleToPackageRefactoring().run()
                            endfunction "}}}
                            
    1              0.000001 fun! pymode#rope#autoimport(word) "{{{
                                PymodePython rope.autoimport()
                            endfunction "}}}
                            
    1              0.000001 fun! pymode#rope#generate_function() "{{{
                                if !pymode#save()
                                    return 0
                                endif
                                PymodePython rope.GenerateElementRefactoring('function').run()
                            endfunction "}}}
                            
    1              0.000001 fun! pymode#rope#generate_class() "{{{
                                if !pymode#save()
                                    return 0
                                endif
                                PymodePython rope.GenerateElementRefactoring('class').run()
                            endfunction "}}}
                            
    1              0.000002 fun! pymode#rope#generate_package() "{{{
                                if !pymode#save()
                                    return 0
                                endif
                                PymodePython rope.GenerateElementRefactoring('package').run()
                            endfunction "}}}

SCRIPT  /home/romain/.vim/pack/bundle/start/python-mode/autoload/pymode/indent.vim
Sourced 1 time
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
                            " PEP8 compatible Python indent file
                            " Language:         Python
                            " Maintainer:       Hynek Schlawack <hs@ox.cx>
                            " Prev Maintainer:  Eric Mc Sween <em@tomcom.de> (address invalid)
                            " Original Author:  David Bustos <bustos@caltech.edu> (address invalid)
                            " Last Change:      2012-06-21
                            " License:          Public Domain
                            
                            
    1              0.000002 function! pymode#indent#get_indent(lnum)
                            
                                " First line has indent 0
                                if a:lnum == 1
                                    return 0
                                endif
                            
                                " If we can find an open parenthesis/bracket/brace, line up with it.
                                call cursor(a:lnum, 1)
                                let parlnum = s:SearchParensPair()
                                if parlnum > 0
                                    let parcol = col('.')
                                    let closing_paren = match(getline(a:lnum), '^\s*[])}]') != -1
                                    if match(getline(parlnum), '[([{]\s*$', parcol - 1) != -1
                                        if closing_paren
                                            return indent(parlnum)
                                        else
                                            return indent(parlnum) + &shiftwidth
                                        endif
                                    else
                                        return parcol
                                    endif
                                endif
                            
                                " Examine this line
                                let thisline = getline(a:lnum)
                                let thisindent = indent(a:lnum)
                            
                                " If the line starts with 'elif' or 'else', line up with 'if' or 'elif'
                                if thisline =~ '^\s*\(elif\|else\)\>'
                                    let bslnum = s:BlockStarter(a:lnum, '^\s*\(if\|elif\)\>')
                                    if bslnum > 0
                                        return indent(bslnum)
                                    else
                                        return -1
                                    endif
                                endif
                            
                                " If the line starts with 'except' or 'finally', line up with 'try'
                                " or 'except'
                                if thisline =~ '^\s*\(except\|finally\)\>'
                                    let bslnum = s:BlockStarter(a:lnum, '^\s*\(try\|except\)\>')
                                    if bslnum > 0
                                        return indent(bslnum)
                                    else
                                        return -1
                                    endif
                                endif
                            
                                " Examine previous line
                                let plnum = a:lnum - 1
                                let pline = getline(plnum)
                                let sslnum = s:StatementStart(plnum)
                            
                                " If the previous line is blank, keep the same indentation
                                if pline =~ '^\s*$'
                                    return -1
                                endif
                            
                                " If this line is explicitly joined, find the first indentation that is a
                                " multiple of four and will distinguish itself from next logical line.
                                if pline =~ '\\$'
                                    let maybe_indent = indent(sslnum) + &sw
                                    let control_structure = '^\s*\(if\|while\|for\s.*\sin\|except\)\s*'
                                    if match(getline(sslnum), control_structure) != -1
                                        " add extra indent to avoid E125
                                        return maybe_indent + &sw
                                    else
                                        " control structure not found
                                        return maybe_indent
                                    endif
                                endif
                            
                                " If the previous line ended with a colon and is not a comment, indent
                                " relative to statement start.
                                if pline =~ '^[^#]*:\s*\(#.*\)\?$'
                                    return indent(sslnum) + &sw
                                endif
                            
                                " If the previous line was a stop-execution statement or a pass
                                if getline(sslnum) =~ '^\s*\(break\|continue\|raise\|return\|pass\)\>'
                                    " See if the user has already dedented
                                    if indent(a:lnum) > indent(sslnum) - &sw
                                        " If not, recommend one dedent
                                        return indent(sslnum) - &sw
                                    endif
                                    " Otherwise, trust the user
                                    return -1
                                endif
                            
                                " In all other cases, line up with the start of the previous statement.
                                return indent(sslnum)
                            endfunction
                            
                            
                            " Find backwards the closest open parenthesis/bracket/brace.
    1              0.000002 function! s:SearchParensPair() " {{{
                                let line = line('.')
                                let col = col('.')
                            
                                " Skip strings and comments and don't look too far
                                let skip = "line('.') < " . (line - 50) . " ? dummy :" .
                                            \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? ' .
                                            \ '"string\\|comment\\|doctest"'
                            
                                " Search for parentheses
                                call cursor(line, col)
                                let parlnum = searchpair('(', '', ')', 'bW', skip)
                                let parcol = col('.')
                            
                                " Search for brackets
                                call cursor(line, col)
                                let par2lnum = searchpair('\[', '', '\]', 'bW', skip)
                                let par2col = col('.')
                            
                                " Search for braces
                                call cursor(line, col)
                                let par3lnum = searchpair('{', '', '}', 'bW', skip)
                                let par3col = col('.')
                            
                                " Get the closest match
                                if par2lnum > parlnum || (par2lnum == parlnum && par2col > parcol)
                                    let parlnum = par2lnum
                                    let parcol = par2col
                                endif
                                if par3lnum > parlnum || (par3lnum == parlnum && par3col > parcol)
                                    let parlnum = par3lnum
                                    let parcol = par3col
                                endif
                            
                                " Put the cursor on the match
                                if parlnum > 0
                                    call cursor(parlnum, parcol)
                                endif
                                return parlnum
                            endfunction " }}}
                            
                            
                            " Find the start of a multi-line statement
    1              0.000001 function! s:StatementStart(lnum) " {{{
                                let lnum = a:lnum
                                while 1
                                    if getline(lnum - 1) =~ '\\$'
                                        let lnum = lnum - 1
                                    else
                                        call cursor(lnum, 1)
                                        let maybe_lnum = s:SearchParensPair()
                                        if maybe_lnum < 1
                                            return lnum
                                        else
                                            let lnum = maybe_lnum
                                        endif
                                    endif
                                endwhile
                            endfunction " }}}
                            
                            
                            " Find the block starter that matches the current line
    1              0.000001 function! s:BlockStarter(lnum, block_start_re) " {{{
                                let lnum = a:lnum
                                let maxindent = 10000       " whatever
                                while lnum > 1
                                    let lnum = prevnonblank(lnum - 1)
                                    if indent(lnum) < maxindent
                                        if getline(lnum) =~ a:block_start_re
                                            return lnum
                                        else
                                            let maxindent = indent(lnum)
                                            " It's not worth going further if we reached the top level
                                            if maxindent == 0
                                                return -1
                                            endif
                                        endif
                                    endif
                                endwhile
                                return -1
                            endfunction " }}}

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
Called 2 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    2              0.000029   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
                              endif

FUNCTION  7()
Called 32 times
Total time:   0.000209
 Self time:   0.000209

count  total (s)   self (s)
   32              0.000195   call add(self._sections, [a:group, a:contents])

FUNCTION  airline#util#exec_funcrefs()
Called 5 times
Total time:   0.007461
 Self time:   0.000607

count  total (s)   self (s)
   32              0.000084     for Fn in a:list
   32   0.007181   0.000327       let code = call(Fn, a:000)
   32              0.000060       if code != 0
    5              0.000010         return code
                                  endif
   27              0.000026     endfor
                                return 0

FUNCTION  <SNR>72_get_seperator()
Called 22 times
Total time:   0.011469
 Self time:   0.000266

count  total (s)   self (s)
   22   0.005419   0.000113   if airline#builder#should_change_group(a:prev_group, a:group)
   19   0.006018   0.000121     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
    3              0.000008     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>78_DisableOnLargeFile()
Called 55 times
Total time:   0.000256
 Self time:   0.000256

count  total (s)   self (s)
   55              0.000141   if exists( 'b:ycm_largefile' )
   55              0.000073     return b:ycm_largefile
                              endif
                            
                              let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
                              let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
                              if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
                              endif
                              return b:ycm_largefile

FUNCTION  <SNR>72_get_transitioned_seperator()
Called 24 times
Total time:   0.008822
 Self time:   0.000745

count  total (s)   self (s)
   24              0.000032   let line = ''
   24              0.000105   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
                              else
   24   0.008214   0.000137     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   24              0.000097     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   24              0.000091     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   24              0.000051     let line .= '%#'.a:group.'#'
   24              0.000016   endif
   24              0.000028   return line

FUNCTION  <SNR>61_update_untracked()
Called 25 times
Total time:   0.002121
 Self time:   0.001822

count  total (s)   self (s)
   25              0.000464   let file = expand("%:p")
   25              0.000112   if empty(file) || isdirectory(file)
                                return
                              endif
                            
   25              0.000038   let needs_update = 1
   75              0.000123   for vcs in keys(s:vcs_config)
   50              0.000214     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
   50              0.000112     if has_key(s:vcs_config[vcs].untracked, file)
   25              0.000030       let needs_update = 0
   25   0.000470   0.000171       call airline#extensions#branch#update_untracked_config(file, vcs)
   25              0.000011     endif
   50              0.000031   endfor
                            
   25              0.000027   if !needs_update
   25              0.000022     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                let config = s:vcs_config[vcs]
                                if g:airline#init#vim_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
                                  noa call airline#async#vim_vcs_untracked(config, file)
                                else
                                  " nvim async or vim without job-feature
                                  noa call airline#async#nvim_vcs_untracked(config, file, vcs)
                                endif
                              endfor

FUNCTION  <SNR>74_get_closing()
Called 1 time
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    1              0.000000   let i = -1
    1              0.000001   let clo = ''
    2              0.000002   while 1
    2              0.000012     let i = match(a:line, '[{}()\[\]]', i+1)
    3              0.000003     if i == -1 | break | endif
    1              0.000001     let ch = a:line[i]
    1              0.000001     if ch == '{'
                                  let clo = '}' . clo
                                elseif ch == '}'
                                  if clo[0] != '}' | return '' | endif
                                  let clo = clo[1:]
                                elseif ch == '('
    1              0.000001       let clo = ')' . clo
    1              0.000001     elseif ch == ')'
                                  if clo[0] != ')' | return '' | endif
                                  let clo = clo[1:]
                                elseif ch == '['
                                  let clo = ']' . clo
                                elseif ch == ']'
                                  if clo[0] != ']' | return '' | endif
                                  let clo = clo[1:]
                                endif
    1              0.000000   endwhile
    1              0.000000   return clo

FUNCTION  <SNR>78_PollCompletion()
Called 48 times
Total time:   0.005311
 Self time:   0.001042

count  total (s)   self (s)
   48   0.003074   0.000380   if !s:Pyeval( 'ycm_state.CompletionRequestReady()' )
   44              0.000429     let s:pollers.completion.id = timer_start( s:pollers.completion.wait_milliseconds, function( 's:PollCompletion' ) )
   44              0.000044     return
                              endif
                            
    4   0.001471   0.000037   let s:completion = s:Pyeval( 'ycm_state.GetCompletionResponse()' )
    4   0.000175   0.000034   call s:Complete()

FUNCTION  <SNR>69_hl_group_exists()
Called 251 times
Total time:   0.002016
 Self time:   0.002016

count  total (s)   self (s)
  251              0.000495   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
  251              0.000177   return 1

FUNCTION  <SNR>78_AllowedToCompleteInCurrentBuffer()
Called 57 times
Total time:   0.002618
 Self time:   0.000275

count  total (s)   self (s)
   57   0.002598   0.000255   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  airline#check_mode()
Called 31 times
Total time:   0.085191
 Self time:   0.003208

count  total (s)   self (s)
   31              0.000094   if !has_key(s:contexts, a:winnr)
                                return ''
                              endif
   31              0.000100   let context = s:contexts[a:winnr]
                            
   31              0.000091   if get(w:, 'airline_active', 1)
   27              0.000081     let l:m = mode(1)
   27              0.000046     if l:m ==# "i"
   17              0.000030       let l:mode = ['insert']
   17              0.000020     elseif l:m[0] ==# "i"
    6              0.000008       let l:mode = ['insert']
    6              0.000006     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
                                elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                elseif l:m[0] ==# "c"
                                  let l:mode = ['commandline']
                                elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
                                elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
                                else
    4              0.000021       let l:mode = ['normal']
    4              0.000006     endif
   27              0.000110     if index(['Rv', 'no', 'ni', 'ix', 'ic'], l:m) == -1
   21              0.000050       let l:m = l:m[0]
   21              0.000012     endif
   27              0.000117     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   27              0.000020   else
    4              0.000006     let l:mode = ['inactive']
    4              0.000013     let w:airline_current_mode = get(g:airline_mode_map, '__')
    4              0.000001   endif
                            
   31              0.000084   if g:airline_detect_modified && &modified
   24              0.000056     call add(l:mode, 'modified')
   24              0.000011   endif
                            
   31              0.000050   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
   31              0.000113   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
   31              0.000043   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
   31              0.000039   if &readonly || ! &modifiable
    3              0.000008     call add(l:mode, 'readonly')
    3              0.000001   endif
                            
   31              0.000109   let mode_string = join(l:mode)
   31              0.000107   if get(w:, 'airline_lastmode', '') != mode_string
    7   0.002543   0.000091     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    7   0.079248   0.000092     call airline#highlighter#highlight(l:mode, context.bufnr)
    7   0.000424   0.000049     call airline#util#doautocmd('AirlineModeChanged')
    7              0.000012     let w:airline_lastmode = mode_string
    7              0.000003   endif
                            
   31              0.000027   return ''

FUNCTION  5()
Called 5 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    5              0.000032   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  airline#util#append()
Called 175 times
Total time:   0.001367
 Self time:   0.001367

count  total (s)   self (s)
  175              0.000292   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
  175              0.000424   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  175              0.000391   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#extensions#branch#update_untracked_config()
Called 25 times
Total time:   0.000299
 Self time:   0.000299

count  total (s)   self (s)
   25              0.000079   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
                              endif

FUNCTION  <SNR>78_VisitedBufferRequiresReparse()
Called 4 times
Total time:   0.000102
 Self time:   0.000047

count  total (s)   self (s)
    4              0.000021   if bufnr( '%' ) ==# s:previous_allowed_buffer_number
    2              0.000002     return 0
                              endif
                            
    2   0.000069   0.000014   return s:AllowedToCompleteInCurrentBuffer()

FUNCTION  <SNR>76_can_diffoff()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000008   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  airline#themes#get_highlight()
Called 210 times
Total time:   0.018368
 Self time:   0.001022

count  total (s)   self (s)
  210   0.018319   0.000973   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>69_get_syn()
Called 1122 times
Total time:   0.022766
 Self time:   0.022766

count  total (s)   self (s)
 1122              0.002268   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
 1122              0.001061   let color = ''
 1122              0.002170   if hlexists(a:group)
 1060              0.004096     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 1060              0.000557   endif
 1122              0.001963   if empty(color) || color == -1
                                " should always exists
   62              0.000333     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
   62              0.000120     if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
   62              0.000037   endif
 1122              0.000995   return color

FUNCTION  airline#util#has_fugitive()
Called 25 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
   25              0.000095   return exists('*fugitive#head') || exists('*FugitiveHead')

FUNCTION  pymode#lint#show_errormessage()
Called 1 time
Total time:   0.000025
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000015   0.000006     let loclist = g:PymodeLocList.current()
    1   0.000008   0.000005     if loclist.is_empty()
    1              0.000001         return
                                endif
                            
                                let l = line('.')
                                if l == b:pymode_error_line
                                    return
                                endif
                                let b:pymode_error_line = l
                                if has_key(loclist._messages, l)
                                    call pymode#wide_message(loclist._messages[l])
                                else
                                    echo
                                endif

FUNCTION  <SNR>69_group_not_done()
Called 243 times
Total time:   0.001546
 Self time:   0.001546

count  total (s)   self (s)
  243              0.000561   if index(a:list, a:name) == -1
  195              0.000452     call add(a:list, a:name)
  195              0.000182     return 1
                              else
   48              0.000050     if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
                                endif
   48              0.000027     return 0
                              endif

FUNCTION  pymode#indent#get_indent()
Called 2 times
Total time:   0.005203
 Self time:   0.000060

count  total (s)   self (s)
                            
                                " First line has indent 0
    2              0.000002     if a:lnum == 1
                                    return 0
                                endif
                            
                                " If we can find an open parenthesis/bracket/brace, line up with it.
    2              0.000003     call cursor(a:lnum, 1)
    2   0.005153   0.000010     let parlnum = s:SearchParensPair()
    2              0.000002     if parlnum > 0
    2              0.000002         let parcol = col('.')
    2              0.000014         let closing_paren = match(getline(a:lnum), '^\s*[])}]') != -1
    2              0.000012         if match(getline(parlnum), '[([{]\s*$', parcol - 1) != -1
    2              0.000002             if closing_paren
                                            return indent(parlnum)
                                        else
    2              0.000004                 return indent(parlnum) + &shiftwidth
                                        endif
                                    else
                                        return parcol
                                    endif
                                endif
                            
                                " Examine this line
                                let thisline = getline(a:lnum)
                                let thisindent = indent(a:lnum)
                            
                                " If the line starts with 'elif' or 'else', line up with 'if' or 'elif'
                                if thisline =~ '^\s*\(elif\|else\)\>'
                                    let bslnum = s:BlockStarter(a:lnum, '^\s*\(if\|elif\)\>')
                                    if bslnum > 0
                                        return indent(bslnum)
                                    else
                                        return -1
                                    endif
                                endif
                            
                                " If the line starts with 'except' or 'finally', line up with 'try'
                                " or 'except'
                                if thisline =~ '^\s*\(except\|finally\)\>'
                                    let bslnum = s:BlockStarter(a:lnum, '^\s*\(try\|except\)\>')
                                    if bslnum > 0
                                        return indent(bslnum)
                                    else
                                        return -1
                                    endif
                                endif
                            
                                " Examine previous line
                                let plnum = a:lnum - 1
                                let pline = getline(plnum)
                                let sslnum = s:StatementStart(plnum)
                            
                                " If the previous line is blank, keep the same indentation
                                if pline =~ '^\s*$'
                                    return -1
                                endif
                            
                                " If this line is explicitly joined, find the first indentation that is a
                                " multiple of four and will distinguish itself from next logical line.
                                if pline =~ '\\$'
                                    let maybe_indent = indent(sslnum) + &sw
                                    let control_structure = '^\s*\(if\|while\|for\s.*\sin\|except\)\s*'
                                    if match(getline(sslnum), control_structure) != -1
                                        " add extra indent to avoid E125
                                        return maybe_indent + &sw
                                    else
                                        " control structure not found
                                        return maybe_indent
                                    endif
                                endif
                            
                                " If the previous line ended with a colon and is not a comment, indent
                                " relative to statement start.
                                if pline =~ '^[^#]*:\s*\(#.*\)\?$'
                                    return indent(sslnum) + &sw
                                endif
                            
                                " If the previous line was a stop-execution statement or a pass
                                if getline(sslnum) =~ '^\s*\(break\|continue\|raise\|return\|pass\)\>'
                                    " See if the user has already dedented
                                    if indent(a:lnum) > indent(sslnum) - &sw
                                        " If not, recommend one dedent
                                        return indent(sslnum) - &sw
                                    endif
                                    " Otherwise, trust the user
                                    return -1
                                endif
                            
                                " In all other cases, line up with the start of the previous statement.
                                return indent(sslnum)

FUNCTION  airline#parts#filetype()
Called 31 times
Total time:   0.000460
 Self time:   0.000195

count  total (s)   self (s)
   31   0.000443   0.000178   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? 'â€¦' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 3 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
    3              0.000020   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  airline#parts#iminsert()
Called 25 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
   25              0.000054   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
   25              0.000021   return ''

FUNCTION  airline#extensions#term#apply()
Called 3 times
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
    3              0.000008   if &buftype == 'terminal'
                                let spc = g:airline_symbols.space
                            
                                let name=get(g:airline_mode_map, 't', 't')
                                call a:1.add_section('airline_a', spc.name.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_term', spc.s:termname())
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
                              endif

FUNCTION  <SNR>61_update_hg_branch()
Called 25 times
Total time:   0.001363
 Self time:   0.001285

count  total (s)   self (s)
   25   0.000160   0.000082   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
   25              0.000058     let s:vcs_config['mercurial'].branch = ''
   25              0.000014   endif

FUNCTION  <SNR>72_get_accented_line()
Called 32 times
Total time:   0.001793
 Self time:   0.001793

count  total (s)   self (s)
   32              0.000054   if a:self._context.active
                                " active window
   24              0.000041     let contents = []
   24              0.000172     let content_parts = split(a:contents, '__accent')
   56              0.000088     for cpart in content_parts
   32              0.000299       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   32              0.000097       call add(contents, cpart)
   32              0.000034     endfor
   24              0.000082     let line = join(contents, a:group)
   24              0.000170     let line = substitute(line, '__restore__', a:group, 'g')
   24              0.000018   else
                                " inactive window
    8              0.000172     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
    8              0.000067     let line = substitute(line, '%#__restore__#', '', 'g')
    8              0.000010   endif
   32              0.000047   return line

FUNCTION  <SNR>78_InvokeCompletion()
Called 4 times
Total time:   0.005198
 Self time:   0.004844

count  total (s)   self (s)
    4              0.004803   exec s:python_command "ycm_state.SendCompletionRequest(" . "vimsupport.GetBoolValue( 's:force_semantic' ) )"
                            
    4   0.000391   0.000037   call s:PollCompletion()

FUNCTION  <SNR>36_record()
Called 9 times
Total time:   0.000791
 Self time:   0.000300

count  total (s)   self (s)
    9              0.000045 	if s:locked | retu | en
    9              0.000033 	let bufnr = a:bufnr + 0
    9              0.000041 	let bufname = bufname(bufnr)
    9              0.000034 	if bufnr > 0 && !empty(bufname)
    4              0.000025 		cal filter(s:mrbs, 'v:val != bufnr')
    4              0.000013 		cal insert(s:mrbs, bufnr)
    4   0.000533   0.000042 		cal s:addtomrufs(bufname)
    4              0.000003 	en

FUNCTION  ale#events#ReadOrEnterEvent()
Called 4 times
Total time:   0.000154
 Self time:   0.000154

count  total (s)   self (s)
                                " Apply pattern options if the variable is set.
    4              0.000029     if get(g:, 'ale_pattern_options_enabled', 1)&& !empty(get(g:, 'ale_pattern_options'))
                                    call ale#pattern_options#SetOptions(a:buffer)
                                endif
                            
                                " When entering a buffer, we are no longer quitting it.
    4              0.000022     call setbufvar(a:buffer, 'ale_quitting', 0)
    4              0.000023     let l:filetype = getbufvar(a:buffer, '&filetype')
    4              0.000022     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
                                " If the file changed outside of Vim, check it on BufEnter,BufRead
    4              0.000013     if getbufvar(a:buffer, 'ale_file_changed')
                                    call ale#events#LintOnEnter(a:buffer)
                                endif

FUNCTION  <SNR>45_LeadingSpaceDisable()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000002     if g:indentLine_newVersion
    1              0.000004         if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
                                        for id in w:indentLine_leadingSpaceId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_leadingSpaceId = []
                                    endif
                            
    1              0.000001         return
                                endif
                            
                                let b:indentLine_leadingSpaceEnabled = 0
                                try
                                    syntax clear IndentLineLeadingSpace
                                catch /^Vim\%((\a\+)\)\=:E28/   " catch error E28
                                endtry

FUNCTION  <SNR>78_OnInsertChar()
Called 36 times
Total time:   0.002217
 Self time:   0.000437

count  total (s)   self (s)
   36   0.001739   0.000129   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
   36              0.000097   call timer_stop( s:pollers.completion.id )
   36   0.000312   0.000142   call s:CloseCompletionMenu()

FUNCTION  12()
Called 5 times
Total time:   0.021168
 Self time:   0.003944

count  total (s)   self (s)
    5              0.000012   let side = 1
    5              0.000010   let line = ''
    5              0.000009   let i = 0
    5              0.000021   let length = len(self._sections)
    5              0.000011   let split = 0
    5              0.000013   let is_empty = 0
    5              0.000012   let prev_group = ''
                            
   42              0.000075   while i < length
   37              0.000117     let section = self._sections[i]
   37              0.000091     let group = section[0]
   37              0.000086     let contents = section[1]
   37              0.000067     let pgroup = prev_group
   37   0.000807   0.000253     let prev_group = airline#builder#get_prev_group(self._sections, i)
   37              0.000115     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
                                elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
                                endif
   37              0.000041     if is_empty
                                  let prev_group = pgroup
                                endif
   37   0.000712   0.000229     let is_empty = s:section_is_empty(self, contents)
                            
   37              0.000038     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
   37              0.000051     if group == ''
                                  let line .= contents
                                elseif group == '|'
    5              0.000007       let side = 0
    5              0.000013       let line .= contents
    5              0.000006       let split = 1
    5              0.000003     else
   32              0.000048       if prev_group == ''
    5              0.000026         let line .= '%#'.group.'#'
    5              0.000008       elseif split
    5              0.000007         if !is_empty
    5   0.002970   0.000045           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    5              0.000005         endif
    5              0.000009         let split = 0
    5              0.000005       else
   22              0.000041         if !is_empty
   22   0.011619   0.000150           let line .= s:get_seperator(self, prev_group, group, side)
   22              0.000013         endif
   22              0.000011       endif
   32   0.002095   0.000302       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   32              0.000022     endif
                            
   37              0.000092     let i = i + 1
   37              0.000045   endwhile
                            
    5              0.000009   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
    2              0.000102     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    2              0.000002   endif
    5              0.000010   return line

FUNCTION  19()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000003     if !exists("b:pymode_loclist")
                                    let b:pymode_loclist = g:PymodeLocList.init([])
                                endif
    1              0.000001     return b:pymode_loclist

FUNCTION  <SNR>69_get_array()
Called 561 times
Total time:   0.003625
 Self time:   0.003625

count  total (s)   self (s)
  561              0.001508   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  561              0.001956   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  airline#highlighter#add_separator()
Called 24 times
Total time:   0.008077
 Self time:   0.000298

count  total (s)   self (s)
   24              0.000126   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   24   0.007945   0.000166   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  ale#ShouldDoNothing()
Called 6 times
Total time:   0.000793
 Self time:   0.000601

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
    6              0.000052     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
                                endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
    6              0.000024     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
    6              0.000026     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
    6              0.000008     if l:filetype is# ''
                                    return 1
                                endif
                            
                                " Do nothing for diff buffers.
    6              0.000018     if getbufvar(a:buffer, '&diff')
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files.
    6              0.000039     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode.
    6              0.000026     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
    6              0.000030     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
    6              0.000007     if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Don't start linting and so on when an operator is pending.
    6   0.000083   0.000055     if ale#util#Mode(1) is# 'no'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox.
    6   0.000123   0.000025     if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
    6   0.000092   0.000026     if ale#FileTooLarge(a:buffer)
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
    6              0.000075     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
    6              0.000008     return 0

FUNCTION  airline#extensions#ale#get_error()
Called 27 times
Total time:   0.002367
 Self time:   0.000109

count  total (s)   self (s)
   27   0.002365   0.000107   return airline#extensions#ale#get('error')

FUNCTION  airline#extensions#po#apply()
Called 3 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    3              0.000017   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
                              endif

FUNCTION  20()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002     return empty(self._loclist)

FUNCTION  <SNR>45_SetConcealOption()
Called 2 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    2              0.000005     if !g:indentLine_setConceal
                                    return
                                endif
    2              0.000015     if !(exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet)
    1              0.000002         let b:indentLine_ConcealOptionSet = 1
    1              0.000002         let b:indentLine_original_concealcursor = &l:concealcursor
    1              0.000002         let b:indentLine_original_conceallevel = &l:conceallevel
    1              0.000006         let &l:concealcursor = exists("g:indentLine_concealcursor") ? g:indentLine_concealcursor : "inc"
    1              0.000006         let &l:conceallevel = exists("g:indentLine_conceallevel") ? g:indentLine_conceallevel : "2"
    1              0.000001     endif

FUNCTION  airline#util#winwidth()
Called 186 times
Total time:   0.001678
 Self time:   0.001678

count  total (s)   self (s)
  186              0.000499   let nr = get(a:000, 0, 0)
  186              0.000418   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
                              else
  186              0.000361     return winwidth(nr)
                              endif

FUNCTION  <SNR>78_OnCompleteDone()
Called 5 times
Total time:   0.002185
 Self time:   0.001878

count  total (s)   self (s)
    5   0.000329   0.000022   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    5              0.001832   exec s:python_command "ycm_state.OnCompleteDone()"

FUNCTION  airline#util#doautocmd()
Called 7 times
Total time:   0.000375
 Self time:   0.000111

count  total (s)   self (s)
    7   0.000373   0.000109   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  <SNR>73_build_sections()
Called 8 times
Total time:   0.004523
 Self time:   0.000682

count  total (s)   self (s)
   42              0.000082   for key in a:keys
   34              0.000135     if (key == 'warning' || key == 'error') && !a:context.active
    4              0.000008       continue
                                endif
   30   0.004078   0.000237     call s:add_section(a:builder, a:context, key)
   30              0.000045   endfor

FUNCTION  pymode#rope#complete_on_dot()
Called 1 time
Total time:   0.032450
 Self time:   0.000153

count  total (s)   self (s)
    1              0.000005     if !exists("*synstack")
                                    return ""
                                end
    2              0.000112     for group in map(synstack(line('.'), col('.') - 1), 'synIDattr(v:val, "name")')
    5              0.000005         for name in ['pythonString', 'pythonComment', 'pythonNumber', 'pythonDocstring']
    4              0.000004             if group == name
                                            return "" 
                                        endif
    4              0.000002         endfor
    1              0.000000     endfor
    1              0.000001     if g:pymode_rope_autoimport_import_after_complete
                                    PymodePython rope.complete_check()
                                endif
    1   0.032304   0.000007     return pymode#rope#complete(1)

FUNCTION  <SNR>45_IndentLinesEnable()
Called 2 times
Total time:   0.001691
 Self time:   0.001618

count  total (s)   self (s)
    2              0.000006     if g:indentLine_newVersion
    2              0.000005         if &diff
                                        return
                                    endif
                            
    2              0.000015         if exists("b:indentLine_enabled") && b:indentLine_enabled == 0
                                        return
                                    endif
                            
    2              0.000009         if !exists("w:indentLine_indentLineId")
    1              0.000010             let w:indentLine_indentLineId = []
    1              0.000002         endif
                            
    2   0.000106   0.000033         call s:SetConcealOption()
                            
    2              0.000006         if g:indentLine_showFirstIndentLevel
                                        call add(w:indentLine_indentLineId, matchadd('Conceal', '^ ', 0, -1, {'conceal': g:indentLine_first_char}))
                                    endif
                            
    2              0.000012         let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
    2              0.000010         let n = len(g:indentLine_char_list)
    2              0.000005         let level = 0
   42              0.000098         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
   40              0.000068             if n > 0
                                            let char = g:indentLine_char_list[level % n]
                                            let level += 1
                                        else
   40              0.000092                 let char = g:indentLine_char
   40              0.000048             endif
   40              0.000792             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': char}))
   40              0.000073         endfor
                            
    2              0.000005         return
                                endif
                            
                                if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    return
                                else
                                    let b:indentLine_enabled = 1
                                endif
                            
                                call s:SetConcealOption()
                            
                                let g:mysyntaxfile = g:indentLine_mysyntaxfile
                            
                                let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
                            
                                if g:indentLine_showFirstIndentLevel
                                    execute 'syntax match IndentLine /^ / containedin=ALL conceal cchar=' . g:indentLine_first_char
                                endif
                            
                                if g:indentLine_faster
                                    execute 'syntax match IndentLineSpace /^\s\+/ containedin=ALL contains=IndentLine'
                                    execute 'syntax match IndentLine / \{'.(space-1).'}\zs / contained conceal cchar=' . g:indentLine_char
                                    execute 'syntax match IndentLine /\t\zs / contained conceal cchar=' . g:indentLine_char
                                else
                                    let pattern = line('$') < g:indentLine_maxLines ? 'v' : 'c'
                                    for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
                                        execute 'syntax match IndentLine /\%(^\s\+\)\@<=\%'.i.pattern.' / containedin=ALL conceal cchar=' . g:indentLine_char
                                    endfor
                                endif

FUNCTION  <SNR>19_Highlight_Matching_Pair()
Called 21 times
Total time:   0.001596
 Self time:   0.001596

count  total (s)   self (s)
                              " Remove any previous match.
   21              0.000067   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   21              0.000063   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
    4              0.000006     return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   17              0.000036   let c_lnum = line('.')
   17              0.000025   let c_col = col('.')
   17              0.000018   let before = 0
                            
   17              0.000031   let text = getline(c_lnum)
   17              0.000245   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   17              0.000025   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
   17              0.000056     let [c_before, c] = matches[1:2]
   17              0.000010   endif
   17              0.000183   let plist = split(&matchpairs, '.\zs[:,]')
   17              0.000053   let i = index(plist, c)
   17              0.000016   if i < 0
                                " not found, in Insert mode try character before the cursor
   17              0.000048     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   16              0.000022       let before = strlen(c_before)
   16              0.000014       let c = c_before
   16              0.000023       let i = index(plist, c)
   16              0.000007     endif
   17              0.000011     if i < 0
                                  " not found, nothing to do
   15              0.000014       return
                                endif
    2              0.000000   endif
                            
                              " Figure out the arguments for searchpairpos().
    2              0.000001   if i % 2 == 0
    2              0.000002     let s_flags = 'nW'
    2              0.000004     let c2 = plist[i + 1]
    2              0.000000   else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
    2              0.000001   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    2              0.000001   if before > 0
    2              0.000005     let has_getcurpos = exists("*getcurpos")
    2              0.000001     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
    2              0.000003       let save_cursor = getcurpos()
    2              0.000000     else
                                  let save_cursor = winsaveview()
                                endif
    2              0.000004     call cursor(c_lnum, c_col - before)
    2              0.000000   endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
    2              0.000004   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
    2              0.000218   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
    2              0.000004   let stoplinebottom = line('w$')
    2              0.000002   let stoplinetop = line('w0')
    2              0.000002   if i % 2 == 0
    2              0.000002     let stopline = stoplinebottom
    2              0.000002   else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    2              0.000004   if mode() == 'i' || mode() == 'R'
    2              0.000006     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    2              0.000001   else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
    2              0.000000   try
    2              0.000029     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
    2              0.000002   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
    2              0.000000   if before > 0
    2              0.000001     if has_getcurpos
    2              0.000004       call setpos('.', save_cursor)
    2              0.000002     else
                                  call winrestview(save_cursor)
                                endif
    2              0.000000   endif
                            
                              " If a match is found setup match highlighting.
    2              0.000002   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  ale#cursor#EchoCursorWarning()
Called 6 times
Total time:   0.001458
 Self time:   0.000445

count  total (s)   self (s)
    6              0.000035     let l:buffer = bufnr('')
                            
    6              0.000015     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    6              0.000035     if mode(1) isnot# 'n'
                                    return
                                endif
                            
    6   0.000830   0.000037     if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
    6   0.000263   0.000043     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
    6              0.000008     if g:ale_echo_cursor
    6              0.000011         if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
                                    elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
                                    endif
    6              0.000004     endif
                            
    6              0.000007     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
                                endif

FUNCTION  ale#util#Mode()
Called 6 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    6              0.000026     return call('mode', a:000)

FUNCTION  airline#extensions#keymap#status()
Called 25 times
Total time:   0.000253
 Self time:   0.000253

count  total (s)   self (s)
   25              0.000132   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   25              0.000106     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  pymode#wide_message()
Called 1 time
Total time:   0.006574
 Self time:   0.006571

count  total (s)   self (s)
    1              0.000005     let x=&ruler | let y=&showcmd
    1   0.000012   0.000010     set noruler noshowcmd
    1              0.006518     redraw
    1              0.000030     echohl Debug | echo strpart("[Pymode] " . a:msg, 0, &columns-1) | echohl none
    1   0.000008   0.000007     let &ruler=x | let &showcmd=y

FUNCTION  <SNR>57_invoke_funcrefs()
Called 5 times
Total time:   0.029140
 Self time:   0.000304

count  total (s)   self (s)
    5   0.000256   0.000049   let builder = airline#builder#new(a:context)
    5   0.007551   0.000090   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    5              0.000010   if err == 1
    5   0.021220   0.000052     let a:context.line = builder.build()
    5              0.000023     let s:contexts[a:context.winnr] = a:context
    5              0.000020     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
    5              0.000047     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
    5              0.000005   endif

FUNCTION  <SNR>28_on_window_changed()
Called 11 times
Total time:   0.030547
 Self time:   0.000696

count  total (s)   self (s)
   11              0.000081   let s:active_winnr = winnr()
                            
   11              0.000062   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
    3              0.000005     return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    8              0.000172   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
    8              0.000181   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    5              0.000008     return
                              endif
    3              0.000020   let g:airline_last_window_changed = l:key
    3   0.000069   0.000046   call s:init()
    3   0.029860   0.000032   call airline#update_statusline()

FUNCTION  ale#statusline#Count()
Called 54 times
Total time:   0.001281
 Self time:   0.000342

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
   54   0.001245   0.000306     return copy(s:GetCounts(a:buffer))

FUNCTION  airline#extensions#default#apply()
Called 5 times
Total time:   0.005489
 Self time:   0.000434

count  total (s)   self (s)
    5              0.000019   let winnr = a:context.winnr
    5              0.000018   let active = a:context.active
                            
    5   0.000084   0.000052   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    3   0.001214   0.000030     call s:build_sections(a:builder, a:context, s:layout[0])
    3              0.000004   else
    2   0.000166   0.000021     let text = s:get_section(winnr, 'c')
    2              0.000007     if empty(text)
    1              0.000004       let text = ' %f%m '
    1              0.000002     endif
    2   0.000047   0.000028     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    2              0.000002   endif
                            
    5   0.000382   0.000069   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    5   0.000056   0.000033   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    5   0.003394   0.000055     call s:build_sections(a:builder, a:context, s:layout[1])
    5              0.000006   endif
                            
    5              0.000009   return 1

FUNCTION  ale#FileTooLarge()
Called 6 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    6              0.000036     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
    6              0.000025     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  <SNR>78_OnFileReadyToParse()
Called 5 times
Total time:   0.006159
 Self time:   0.005493

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    5              0.000014   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    5   0.000696   0.000030   if force_parsing || s:Pyeval( "ycm_state.NeedsReparse()" )
    4              0.005348     exec s:python_command "ycm_state.OnFileReadyToParse()"
                            
    4              0.000021     call timer_stop( s:pollers.file_parse_response.id )
    4              0.000030     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
    4              0.000004   endif

FUNCTION  <SNR>78_Pyeval()
Called 75 times
Total time:   0.006188
 Self time:   0.006188

count  total (s)   self (s)
   75              0.000137   if s:using_python3
   75              0.005945     return py3eval( a:eval_string )
                              endif
                              return pyeval( a:eval_string )

FUNCTION  <SNR>63_airline_ale_count()
Called 54 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
   54              0.000091   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  <SNR>78_OnCursorMovedNormalMode()
Called 1 time
Total time:   0.000136
 Self time:   0.000086

count  total (s)   self (s)
    1   0.000055   0.000005   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    1              0.000079   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  ale#engine#IsCheckingBuffer()
Called 54 times
Total time:   0.000508
 Self time:   0.000508

count  total (s)   self (s)
   54              0.000194     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   54              0.000279     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  airline#extensions#fugitiveline#bufname()
Called 28 times
Total time:   0.001201
 Self time:   0.001101

count  total (s)   self (s)
   28              0.000075   if !exists('b:fugitive_name')
                                let b:fugitive_name = ''
                                try
                                  if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
                                  elseif exists('b:git_dir')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
                                  endif
                                catch
                                endtry
                              endif
                            
   28   0.000206   0.000106   let fmod = s:ModifierFlags()
   28              0.000052   if empty(b:fugitive_name)
   28              0.000387     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  ale#Var()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003     let l:full_name = 'ale_' . a:variable_name
    1              0.000005     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
    1              0.000004     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  FugitiveGitDir()
Called 25 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
   25              0.000037   if !a:0 || a:1 ==# -1
   25              0.000071     return get(b:, 'git_dir', '')
                              elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
                              elseif type(a:1) == type('')
                                return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  <SNR>78_Complete()
Called 8 times
Total time:   0.000200
 Self time:   0.000153

count  total (s)   self (s)
                              " Do not call user's completion function if the start column is after the
                              " current column or if there are no candidates. Close the completion menu
                              " instead. This avoids keeping the user in completion mode.
    8              0.000039   if s:completion.completion_start_column > s:completion.column || empty( s:completion.completions )
    3   0.000016   0.000006     call s:CloseCompletionMenu()
    3              0.000002   else
                                " <c-x><c-u> invokes the user's completion function (which we have set to
                                " youcompleteme#CompleteFunc), and <c-p> tells Vim to select the previous
                                " completion candidate. This is necessary because by default, Vim selects
                                " the first candidate when completion is invoked, and selecting a candidate
                                " automatically replaces the current text with it. Calling <c-p> forces Vim
                                " to deselect the first candidate and in turn preserve the user's current
                                " text until he explicitly chooses to replace it with a completion.
    5   0.000083   0.000046     call s:SendKeys( "\<C-X>\<C-U>\<C-P>" )
    5              0.000005   endif

FUNCTION  airline#extensions#ale#get()
Called 54 times
Total time:   0.005261
 Self time:   0.002810

count  total (s)   self (s)
   54              0.000188   if !exists(':ALELint')
                                return ''
                              endif
                            
   54              0.000164   let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
   54              0.000134   let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
   54              0.000128   let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
   54              0.000128   let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                            
   54              0.000099   let is_err = a:type ==# 'error'
                            
   54   0.000747   0.000239   if ale#engine#IsCheckingBuffer(bufnr('')) == 1
                                return is_err ? '' : checking_symbol
                              endif
                            
   54              0.000107   let symbol = is_err ? error_symbol : warning_symbol
                            
   54   0.001481   0.000200   let counts = ale#statusline#Count(bufnr(''))
   54              0.000179   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
   54              0.000122     let errors = counts.error + counts.style_error
   54              0.000113     let num = is_err ? errors : counts.total - errors
   54              0.000031   else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
                              endif
                            
   54              0.000066   if show_line_numbers == 1
   54   0.001095   0.000433     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  <SNR>74_use_semicolon()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
                              " Only add semicolons if the `;` flag is on.
    1              0.000003   if ! exists('b:closer') | return '' | endif
    1              0.000003   if match(b:closer_flags, ';') == -1 | return '' | endif
                            
                              " Only add semicolons if another line has a semicolon.
                              let used_semi = search(';$', 'wn') > 0
                              if used_semi == "0" | return '' | endif
                            
                              " Don't add semicolons for lines matching `no_semi`.
                              " This allows `function(){ .. }` and `class X { .. }` to not get semicolons.
                              let line = getline(a:ln)
                              if b:closer_no_semi != '0' && match(line, b:closer_no_semi) > -1
                                return ''
                              endif
                            
                              " Don't add semicolons for context lines matching `semi_ctx`.
                              " This allows supressing semi's for those inside object literals
                              let ctx = s:get_context()
                              if ctx != '0'
                                " if context is not a js function, don't semicolonize
                                if b:closer_semi_ctx != '0' && match(ctx, b:closer_semi_ctx) == -1 | return '' | endif
                              endif
                            
                              return ';'

FUNCTION  airline#util#wrap()
Called 221 times
Total time:   0.001175
 Self time:   0.001005

count  total (s)   self (s)
  221   0.000649   0.000479   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
  221              0.000198   return a:text

FUNCTION  <SNR>78_InsideCommentOrString()
Called 8 times
Total time:   0.000836
 Self time:   0.000836

count  total (s)   self (s)
                              " Has to be col('.') -1 because col('.') doesn't exist at this point. We are
                              " in insert mode when this func is called.
    8              0.000769   let syntax_group = synIDattr( synIDtrans( synID( line( '.' ), col( '.' ) - 1, 1 ) ), 'name')
                            
    8              0.000020   if stridx(syntax_group, 'Comment') > -1
                                return 1
                              endif
                            
    8              0.000012   if stridx(syntax_group, 'String') > -1
                                return 2
                              endif
                            
    8              0.000005   return 0

FUNCTION  <SNR>78_SendKeys()
Called 7 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
                              " By default keys are added to the end of the typeahead buffer. If there are
                              " already keys in the buffer, they will be processed first and may change the
                              " state that our keys combination was sent for (e.g. <C-X><C-U><C-P> in normal
                              " mode instead of insert mode or <C-e> outside of completion mode). We avoid
                              " that by inserting the keys at the start of the typeahead buffer with the 'i'
                              " option. Also, we don't want the keys to be remapped to something else so we
                              " add the 'n' option.
    7              0.000038   call feedkeys( a:keys, 'in' )

FUNCTION  airline#extensions#term#inactive_apply()
Called 2 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    2              0.000014   if getbufvar(a:2.bufnr, '&buftype') == 'terminal'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'TERMINAL'.spc)
                                call a:1.add_section('airline_b', spc.'%f')
                                return 1
                              endif

FUNCTION  airline#builder#get_prev_group()
Called 37 times
Total time:   0.000554
 Self time:   0.000554

count  total (s)   self (s)
   37              0.000097   let x = a:i - 1
   42              0.000074   while x >= 0
   37              0.000117     let group = a:sections[x][0]
   37              0.000089     if group != '' && group != '|'
   32              0.000052       return group
                                endif
    5              0.000007     let x = x - 1
    5              0.000005   endwhile
    5              0.000008   return ''

FUNCTION  ale#util#InSandbox()
Called 6 times
Total time:   0.000098
 Self time:   0.000095

count  total (s)   self (s)
    6              0.000006     try
    6   0.000050   0.000047         let &l:equalprg=&l:equalprg
    6              0.000013     catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
    6              0.000007     return 0

FUNCTION  airline#util#getwinvar()
Called 61 times
Total time:   0.000335
 Self time:   0.000335

count  total (s)   self (s)
   61              0.000306     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  <SNR>75_BlockEnd()
Called 5547 times
Total time:   1.103441
 Self time:   1.103441

count  total (s)   self (s)
                                " Note: Make sure to reset cursor position after using this function.
 5547              0.007953     call cursor(a:lnum, 0)
 5547              1.092582     return searchpos('\v^\s{,'.indent('.').'}\S', 'nW')[0] - 1

FUNCTION  airline#extensions#whitespace#check()
Called 27 times
Total time:   0.002451
 Self time:   0.001984

count  total (s)   self (s)
   27              0.000078   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   27              0.000115   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
    2              0.000002     return ''
                              endif
   25              0.000100   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   25              0.000059   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                let check = 'trailing'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  try
                                    let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                  endif
                                endif
                              endif
   25   0.000558   0.000091   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>45_Filter()
Called 4 times
Total time:   0.000210
 Self time:   0.000210

count  total (s)   self (s)
    4              0.000035     if index(g:indentLine_fileTypeExclude, &filetype) != -1
                                    return 0
                                endif
                            
    4              0.000020     if index(g:indentLine_bufTypeExclude, &buftype) != -1
                                    return 0
                                endif
                            
    4              0.000027     if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
                                    return 0
                                endif
                            
    4              0.000017     for name in g:indentLine_bufNameExclude
                                    if matchstr(bufname(''), name) == bufname('')
                                        return 0
                                    endif
                                endfor
                            
    4              0.000009     return 1

FUNCTION  <SNR>84_BufferCacheExists()
Called 54 times
Total time:   0.000286
 Self time:   0.000286

count  total (s)   self (s)
   54              0.000218     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
   54              0.000057         return 0
                                endif
                            
                                return 1

FUNCTION  <SNR>78_IdentifierFinishedOperations()
Called 8 times
Total time:   0.006886
 Self time:   0.006173

count  total (s)   self (s)
    8   0.000735   0.000022   if !s:Pyeval( 'base.CurrentIdentifierFinished()' )
    3              0.000003     return
                              endif
    5              0.006091   exec s:python_command "ycm_state.OnCurrentIdentifierFinished()"
    5              0.000034   let s:force_semantic = 0
    5              0.000009   let s:completion = s:default_completion

FUNCTION  <SNR>45_IndentLinesDisable()
Called 1 time
Total time:   0.000209
 Self time:   0.000194

count  total (s)   self (s)
    1              0.000001     if g:indentLine_newVersion
    1              0.000005         if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
   21              0.000023             for id in w:indentLine_indentLineId
   20              0.000017                 try
   20              0.000047                     call matchdelete(id)
   20              0.000028                 catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
   20              0.000018             endfor
    1              0.000004             let w:indentLine_indentLineId = []
    1              0.000001         endif
                            
    1   0.000029   0.000014         call s:ResetConcealOption()
    1              0.000002         return
                                endif
                            
                                let b:indentLine_enabled = 0
                                try
                                    syntax clear IndentLine
                                    syntax clear IndentLineSpace
                                catch /^Vim\%((\a\+)\)\=:E28/	" catch error E28
                                endtry

FUNCTION  airline#update_statusline()
Called 3 times
Total time:   0.029828
 Self time:   0.000326

count  total (s)   self (s)
    3   0.000068   0.000039   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    3              0.000051   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    3   0.009106   0.000044   call airline#update_statusline_inactive(range)
                            
    3              0.000015   unlet! w:airline_render_left w:airline_render_right
    3              0.000069   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    3              0.000010   let w:airline_active = 1
    3              0.000027   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    3   0.020457   0.000046   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  airline#update_statusline_inactive()
Called 3 times
Total time:   0.009062
 Self time:   0.000300

count  total (s)   self (s)
    3   0.000050   0.000029   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    5              0.000021   for nr in a:range
    2   0.000025   0.000013     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
    2              0.000014     call setwinvar(nr, 'airline_active', 0)
    2              0.000021     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    2              0.000009     if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
                                endif
    2   0.008759   0.000030     call s:invoke_funcrefs(context, s:inactive_funcrefs)
    2              0.000004   endfor

FUNCTION  <SNR>78_UpdateMatches()
Called 8 times
Total time:   0.001532
 Self time:   0.001532

count  total (s)   self (s)
    8              0.001526   exec s:python_command "ycm_state.UpdateMatches()"

FUNCTION  FugitiveHead()
Called 25 times
Total time:   0.002035
 Self time:   0.000352

count  total (s)   self (s)
   25   0.000254   0.000129   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
   25              0.000037   if empty(dir)
                                return ''
                              endif
   25   0.001703   0.000145   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  airline#highlighter#highlight()
Called 7 times
Total time:   0.079156
 Self time:   0.013059

count  total (s)   self (s)
    7              0.000021   let bufnr = a:0 ? a:1 : ''
    7              0.000029   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    7              0.000082   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    7              0.000022   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    7              0.000013   let airline_grouplist = []
    7              0.000036   let buffers_in_tabpage = sort(tabpagebuflist())
    7              0.000022   if exists("*uniq")
    7              0.000019     let buffers_in_tabpage = uniq(buffers_in_tabpage)
    7              0.000005   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   20              0.000036   for mode in reverse(mapped)
   13              0.000062     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   11              0.000032       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  141              0.000206       for kvp in items(dict)
  130              0.000226         let mode_colors = kvp[1]
  130              0.000165         let name = kvp[0]
  130              0.000273         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
    3              0.000005           let name = 'airline_c'.bufnr
    3              0.000001         endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  130              0.000793         if name =~# 'airline_c\d\+'
    5              0.000036           let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
    5              0.000010           if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
                                      endif
    5              0.000011         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
   49              0.000037           continue
                                    endif
   81   0.000943   0.000370         if s:group_not_done(airline_grouplist, name.suffix)
   65   0.011978   0.000311           call airline#highlighter#exec(name.suffix, mode_colors)
   65              0.000040         endif
                            
  243              0.000330         for accent in keys(s:accents)
  162              0.000305           if !has_key(p.accents, accent)
                                        continue
                                      endif
  162              0.000387           let colors = copy(mode_colors)
  162              0.000321           if p.accents[accent][0] != ''
   81              0.000178             let colors[0] = p.accents[accent][0]
   81              0.000032           endif
  162              0.000236           if p.accents[accent][2] != ''
   81              0.000165             let colors[2] = p.accents[accent][2]
   81              0.000033           endif
  162              0.000228           if len(colors) >= 5
  162              0.000386             let colors[4] = get(p.accents[accent], 4, '')
  162              0.000088           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
  162   0.001686   0.000713           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  130   0.022357   0.000603             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  130              0.000058           endif
  162              0.000106         endfor
   81              0.000048       endfor
                            
   11              0.000018       if empty(s:separators)
                                    " nothing to be done
                                    continue
                                  endif
                                  " TODO: optimize this
  101              0.000137       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
   90   0.031799   0.000669         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   90              0.000052       endfor
   11              0.000007     endif
   13              0.000012   endfor

FUNCTION  airline#parts#ffenc()
Called 31 times
Total time:   0.000660
 Self time:   0.000660

count  total (s)   self (s)
   31              0.000086   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   31              0.000052   let bomb     = &l:bomb ? '[BOM]' : ''
   31              0.000228   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   31              0.000130   if expected is# &fenc.bomb.ff
                                return ''
                              else
   31              0.000100     return &fenc.bomb.ff
                              endif

FUNCTION  <SNR>78_ClosePreviewWindowIfNeeded()
Called 13 times
Total time:   0.000538
 Self time:   0.000538

count  total (s)   self (s)
   13              0.000085   let current_buffer_name = bufname('')
                            
                              " We don't want to try to close the preview window in special buffers like
                              " "[Command Line]"; if we do, Vim goes bonkers. Special buffers always start
                              " with '['.
   13              0.000045   if current_buffer_name[ 0 ] == '['
                                return
                              endif
                            
                              " This command does the actual closing of the preview window. If no preview
                              " window is shown, nothing happens.
   13              0.000343   pclose

FUNCTION  airline#util#ignore_buf()
Called 28 times
Total time:   0.000764
 Self time:   0.000764

count  total (s)   self (s)
   28              0.000181   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify|!')
   28              0.000566   return match(a:name, pat) > -1

FUNCTION  pymode#rope#complete()
Called 1 time
Total time:   0.032297
 Self time:   0.025723

count  total (s)   self (s)
    1              0.000001     if pumvisible()
                                    return "\<C-n>"
                                end
    1              0.000001     if a:dot
    1   0.032282   0.025708         PymodePython rope.complete(True)
    1              0.000002     else
                                    PymodePython rope.complete()
                                end
    1              0.000004     return pumvisible() ? "\<C-p>\<Down>" : ""

FUNCTION  closer#close()
Called 1 time
Total time:   0.000130
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000003   if ! get(b:, 'closer') | return '' | endif
                            
                              " supress if it broke off a line (pressed enter not at the end)
    1              0.000007   if match(getline('.'), '^\s*$') == -1 | return '' | endif
                            
    1              0.000003   let ln = line('.') - 1
    1              0.000001   let line = getline(ln)
    1              0.000005   let indent = matchstr(line, '^\s*')
                            
    1   0.000073   0.000006   let closetag = s:get_closing(line)
    1              0.000002   if closetag == '' | return "" | endif
                            
    1   0.000027   0.000020   let closetag = closetag . s:use_semicolon(ln)
                            
                              " <esc>a will go back to the 0.
                              " I dont know why <esc>A is needed at the end, but it seems to fix
                              " pressing escape after expansion.
    1              0.000005   return "\<Esc>a" .indent . closetag . "\<C-O>O\<Esc>a" . indent . "\<Tab>\<Esc>A"

FUNCTION  airline#update_tabline()
Called 8 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    8              0.000018   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
                              endif

FUNCTION  airline#parts#get()
Called 25 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
   25              0.000093   return get(s:parts, a:key, {})

FUNCTION  <SNR>78_OnBufferEnter()
Called 4 times
Total time:   0.000148
 Self time:   0.000046

count  total (s)   self (s)
    4   0.000140   0.000038   if !s:VisitedBufferRequiresReparse()
    4              0.000005     return
                              endif
                            
                              call s:SetUpCompleteopt()
                              call s:SetCompleteFunc()
                              call s:StartMessagePoll()
                            
                              exec s:python_command "ycm_state.OnBufferVisit()"
                              " Last parse may be outdated because of changes from other buffers. Force a
                              " new parse.
                              call s:OnFileReadyToParse( 1 )

FUNCTION  airline#parts#paste()
Called 25 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
   25              0.000055   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>72_section_is_empty()
Called 37 times
Total time:   0.000483
 Self time:   0.000483

count  total (s)   self (s)
   37              0.000066   let start=1
                            
                              " do not check for inactive windows or the tabline
   37              0.000083   if a:self._context.active == 0
   10              0.000019     return 0
                              elseif get(a:self._context, 'tabline', 0)
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
   27              0.000070   if get(g:, 'airline_skip_empty_sections', 0) == 0
   27              0.000026     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  <SNR>78_OnInsertLeave()
Called 5 times
Total time:   0.014329
 Self time:   0.007739

count  total (s)   self (s)
    5   0.000336   0.000021   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    5              0.000020   call timer_stop( s:pollers.completion.id )
    5              0.000009   let s:force_semantic = 0
    5              0.000013   let s:completion = s:default_completion
                            
    5   0.006189   0.000030   call s:OnFileReadyToParse()
    5              0.007518   exec s:python_command "ycm_state.OnInsertLeave()"
    5              0.000036   if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
    5   0.000176   0.000060     call s:ClosePreviewWindowIfNeeded()
    5              0.000006   endif

FUNCTION  ale#util#BinarySearch()
Called 6 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
    6              0.000007     let l:min = 0
    6              0.000017     let l:max = len(a:loclist) - 1
                            
    6              0.000007     while 1
    6              0.000010         if l:max < l:min
    6              0.000008             return -1
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
                                    if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
                                    elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
                                endwhile

FUNCTION  airline#parts#readonly()
Called 28 times
Total time:   0.001177
 Self time:   0.000413

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
   28   0.000959   0.000195   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
                              endif
   28              0.000058   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
   28              0.000043     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
Called 25 times
Total time:   0.001558
 Self time:   0.001558

count  total (s)   self (s)
   25              0.000065   let dir = a:0 > 1 ? a:2 : get(b:, 'git_dir', '')
   25              0.000485   if empty(dir) || !filereadable(dir . '/HEAD')
                                return ''
                              endif
   25              0.000403   let head = readfile(dir . '/HEAD')[0]
   25              0.000186   if head =~# '^ref: '
   25              0.000343     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  <SNR>73_get_section()
Called 43 times
Total time:   0.002809
 Self time:   0.002166

count  total (s)   self (s)
   43              0.000181   if has_key(s:section_truncate_width, a:key)
   30   0.000652   0.000227     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
                                endif
   30              0.000030   endif
   43              0.000123   let spc = g:airline_symbols.space
   43              0.000258   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
   43   0.000624   0.000406   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   43              0.000383   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   43              0.000238   return empty(text) ? '' : prefix.text.suffix

FUNCTION  airline#builder#should_change_group()
Called 22 times
Total time:   0.005306
 Self time:   0.000515

count  total (s)   self (s)
   22              0.000046   if a:group1 == a:group2
                                return 0
                              endif
   22   0.002628   0.000113   let color1 = airline#highlighter#get_highlight(a:group1)
   22   0.002387   0.000111   let color2 = airline#highlighter#get_highlight(a:group2)
   22              0.000030   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
   22              0.000079     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>62_ModifierFlags()
Called 28 times
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
   28              0.000085   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  <SNR>61_update_git_branch()
Called 25 times
Total time:   0.002957
 Self time:   0.000604

count  total (s)   self (s)
   25   0.000201   0.000098   if !airline#util#has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
   25   0.002254   0.000219   let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
   25   0.000345   0.000130   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
                              endif

FUNCTION  <SNR>63_new_airline_ale_get_line_number()
Called 54 times
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
                              " The FirstProblem call in ALE is a far more efficient way
                              " of obtaining line number data. If the installed ALE supports
                              " it, we should use this method of getting line data.
   54              0.000051   if a:cnt == 0
   54              0.000034     return ''
                              endif
                              let l:buffer = bufnr('')
                            
                              " Try to get the first error from ALE.
                              let l:result = ale#statusline#FirstProblem(l:buffer, a:type)
                              if empty(l:result)
                                " If there are no errors then try and check for style errors.
                                let l:result =  ale#statusline#FirstProblem(l:buffer, 'style_' . a:type)
                              endif
                            
                              if empty(l:result)
                                  return ''
                              endif
                            
                              let l:open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
                              let l:close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
                              return open_lnum_symbol . l:result.lnum . close_lnum_symbol

FUNCTION  ale#util#FindItemAtCursor()
Called 6 times
Total time:   0.000220
 Self time:   0.000156

count  total (s)   self (s)
    6              0.000035     let l:info = get(g:ale_buffer_info, a:buffer, {})
    6              0.000016     let l:loclist = get(l:info, 'loclist', [])
    6              0.000020     let l:pos = getpos('.')
    6   0.000110   0.000046     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
    6              0.000019     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
    6              0.000011     return [l:info, l:loc]

FUNCTION  <SNR>78_OnTextChangedInsertMode()
Called 8 times
Total time:   0.014768
 Self time:   0.000658

count  total (s)   self (s)
    8   0.000318   0.000037   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    8              0.000007   if s:completion_stopped
                                let s:completion_stopped = 0
                                let s:completion = s:default_completion
                                return
                              endif
                            
    8   0.006917   0.000031   call s:IdentifierFinishedOperations()
                            
                              " We have to make sure we correctly leave semantic mode even when the user
                              " inserts something like a "operator[]" candidate string which fails
                              " CurrentIdentifierFinished check.
    8              0.000022   if s:force_semantic && !s:Pyeval( 'base.LastEnteredCharIsIdentifierChar()' )
                                let s:force_semantic = 0
                              endif
                            
    8   0.001361   0.000097   if &completefunc == "youcompleteme#CompleteFunc" && ( g:ycm_auto_trigger || s:force_semantic ) && !s:InsideCommentOrStringAndShouldStop() && !s:OnBlankLine()
                                " Immediately call previous completion to avoid flickers.
    4   0.000078   0.000019     call s:Complete()
    4   0.005209   0.000011     call s:InvokeCompletion()
    4              0.000004   endif
                            
    8              0.000285   exec s:python_command "ycm_state.OnCursorMoved()"
                            
    8              0.000012   if g:ycm_autoclose_preview_window_after_completion
    8   0.000463   0.000041     call s:ClosePreviewWindowIfNeeded()
    8              0.000004   endif

FUNCTION  <SNR>85_StopCursorTimer()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000001     if s:cursor_timer != -1
                                    call timer_stop(s:cursor_timer)
                                    let s:cursor_timer = -1
                                endif

FUNCTION  <SNR>69_exec_separator()
Called 114 times
Total time:   0.038909
 Self time:   0.003027

count  total (s)   self (s)
  114              0.000167   if pumvisible()
    9              0.000009     return
                              endif
  105              0.000263   let group = a:from.'_to_'.a:to.a:suffix
  105   0.009884   0.000411   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  105   0.009315   0.000420   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  105              0.000096   if a:inverse
   26              0.000110     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   26              0.000013   else
   79              0.000319     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   79              0.000034   endif
  105              0.000211   let a:dict[group] = colors
  105   0.017982   0.000468   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>78_PollFileParseResponse()
Called 1 time
Total time:   0.001118
 Self time:   0.000738

count  total (s)   self (s)
    1   0.000308   0.000034   if !s:Pyeval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
                              endif
                            
    1              0.000627   exec s:python_command "ycm_state.HandleFileParseRequest()"
    1   0.000133   0.000027   if s:Pyeval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
                              endif

FUNCTION  airline#highlighter#exec()
Called 307 times
Total time:   0.053124
 Self time:   0.013377

count  total (s)   self (s)
  307              0.000410   if pumvisible()
                                return
                              endif
  307              0.000408   let colors = a:colors
  307              0.000314   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  307   0.027948   0.001136   let old_hi = airline#highlighter#get_highlight(a:group)
  307              0.000485   if len(colors) == 4
  110              0.000223     call add(colors, '')
  110              0.000057   endif
  307              0.000330   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
  307              0.001638     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  307              0.000161   endif
  307   0.007328   0.001008   let colors = s:CheckDefined(colors)
  307   0.003177   0.001161   if old_hi != new_hi || !s:hl_group_exists(a:group)
   56   0.004911   0.000312     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
   56              0.000449     exe cmd
   56              0.000141     if has_key(s:hl_groups, a:group)
   56              0.000124       let s:hl_groups[a:group] = colors
   56              0.000033     endif
   56              0.000029   endif

FUNCTION  <SNR>84_CreateCountDict()
Called 54 times
Total time:   0.000287
 Self time:   0.000287

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
   54              0.000230     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  <SNR>89_SearchParensPair()
Called 2 times
Total time:   0.005143
 Self time:   0.005143

count  total (s)   self (s)
    2              0.000003     let line = line('.')
    2              0.000004     let col = col('.')
                            
                                " Skip strings and comments and don't look too far
    2              0.000007     let skip = "line('.') < " . (line - 50) . " ? dummy :" . 'synIDattr(synID(line("."), col("."), 0), "name") =~? ' . '"string\\|comment\\|doctest"'
                            
                                " Search for parentheses
    2              0.000003     call cursor(line, col)
    2              0.000273     let parlnum = searchpair('(', '', ')', 'bW', skip)
    2              0.000002     let parcol = col('.')
                            
                                " Search for brackets
    2              0.000003     call cursor(line, col)
    2              0.002380     let par2lnum = searchpair('\[', '', '\]', 'bW', skip)
    2              0.000004     let par2col = col('.')
                            
                                " Search for braces
    2              0.000004     call cursor(line, col)
    2              0.002428     let par3lnum = searchpair('{', '', '}', 'bW', skip)
    2              0.000002     let par3col = col('.')
                            
                                " Get the closest match
    2              0.000003     if par2lnum > parlnum || (par2lnum == parlnum && par2col > parcol)
                                    let parlnum = par2lnum
                                    let parcol = par2col
                                endif
    2              0.000002     if par3lnum > parlnum || (par3lnum == parlnum && par3col > parcol)
                                    let parlnum = par3lnum
                                    let parcol = par3col
                                endif
                            
                                " Put the cursor on the match
    2              0.000001     if parlnum > 0
    2              0.000003         call cursor(parlnum, parcol)
    2              0.000002     endif
    2              0.000002     return parlnum

FUNCTION  airline#parts#spell()
Called 25 times
Total time:   0.000582
 Self time:   0.000582

count  total (s)   self (s)
   25              0.000260   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   25              0.000038   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
   25              0.000023   return ''

FUNCTION  <SNR>63_airline_ale_get_line_number()
Called 54 times
Total time:   0.000559
 Self time:   0.000406

count  total (s)   self (s)
                              " Use the new ALE statusline API function if it is available.
   54              0.000139   if exists("*ale#statusline#FirstProblem")
   54   0.000374   0.000221     return s:new_airline_ale_get_line_number(a:cnt, a:type)
                              endif
                            
                              return s:legacy_airline_ale_get_line_number(a:cnt, a:type)

FUNCTION  <SNR>20_LocalBrowse()
Called 4 times
Total time:   0.000211
 Self time:   0.000211

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                              
    4              0.000018   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    4              0.000023   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                            "   call Decho("(s:LocalBrowse) COMBAK#23: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                            "   call Decho("(s:LocalBrowse) COMBAK#24: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                            "    call Decho("(s:LocalBrowse) COMBAK#25: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    4              0.000004   endif
                            "  call Decho("(s:LocalBrowse) COMBAK#26: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  pymode#tools#loclist#init()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000001     return

FUNCTION  <SNR>45_Setup()
Called 2 times
Total time:   0.002176
 Self time:   0.000173

count  total (s)   self (s)
    2              0.000014     if &filetype ==# ""
    1   0.000110   0.000008         call s:InitColor()
    1              0.000001     endif
                            
    2   0.000153   0.000038     if s:Filter() && g:indentLine_enabled || exists("b:indentLine_enabled") && b:indentLine_enabled
    2   0.001735   0.000044         call s:IndentLinesEnable()
    2              0.000003     endif
                            
    2   0.000126   0.000031     if s:Filter() && g:indentLine_leadingSpaceEnabled || exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceEnable()
                                endif

FUNCTION  airline#parts#crypt()
Called 25 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
   25              0.000116   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  <SNR>75_Is_opening_folding()
Called 600 times
Total time:   0.016070
 Self time:   0.016070

count  total (s)   self (s)
                                " Helper function to see if docstring is opening or closing
                            
                                " Cache the result so the loop runs only once per change
  600              0.001325     if get(b:, 'fold_changenr', -1) == changenr()
  599              0.001024         return b:fold_cache[a:lnum]  "If odd then it is an opening
                                else
    1              0.000002         let b:fold_changenr = changenr()
    1              0.000014         let b:fold_cache = []
    1              0.000001     endif
                            
    1              0.000002     let number_of_folding = 0  " To be analized if odd/even to inform if it is opening or closing.
    1              0.000002     let has_open_docstring = 0  " To inform is already has an open docstring.
    1              0.000001     let extra_docstrings = 0  " To help skipping ''' and """ which are not docstrings
                            
                                " The idea of this part of the function is to identify real docstrings and
                                " not just triple quotes (that could be a regular string).
                                "
                                " Iterater over all lines from the start until current line (inclusive)
  244              0.000189     for i in range(1, line('$'))
  243              0.000514         call add(b:fold_cache, number_of_folding % 2)
                            
  243              0.000414         let i_line = getline(i)
                            
  243              0.002334         if i_line =~ s:doc_line_regex 
                                        " echom "case 00 on line " . i
                                        continue
                                    endif
                            
  243              0.002214         if i_line =~ s:doc_begin_regex && ! has_open_docstring
                                        " echom "case 01 on line " . i
                                        " This causes the loop to continue if there is a triple quote which
                                        " is not a docstring.
   13              0.000014             if extra_docstrings > 0
                                            let extra_docstrings = extra_docstrings - 1
                                            continue
                                        else
   13              0.000018                 let has_open_docstring = 1
   13              0.000028                 let number_of_folding = number_of_folding + 1
   13              0.000010             endif
                                    " If it is an end doc and has an open docstring.
   13              0.000019         elseif i_line =~ s:doc_end_regex && has_open_docstring
                                        " echom "case 02 on line " . i
   13              0.000020             let has_open_docstring = 0
   13              0.000027             let number_of_folding = number_of_folding + 1
                            
   13              0.000014         elseif i_line =~ s:doc_general_regex
                                        " echom "extra docstrings on line " . i
                                        let extra_docstrings = extra_docstrings + 1
                                    endif 
  243              0.000172     endfor
                            
    1              0.000003     call add(b:fold_cache, number_of_folding % 2)
                            
    1              0.000003     return b:fold_cache[a:lnum]

FUNCTION  airline#extensions#branch#head()
Called 25 times
Total time:   0.008264
 Self time:   0.000571

count  total (s)   self (s)
   25              0.000076   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
                              endif
                            
   25   0.005686   0.000114   call s:update_branch()
   25   0.002247   0.000126   call s:update_untracked()
                            
   25              0.000088   if exists('b:airline_head') && !empty(b:airline_head)
   25              0.000029     return b:airline_head
                              endif
                            
                              let b:airline_head = ''
                              let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
                              let heads = []
                              for vcs in vcs_priority
                                if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads += [vcs]
                                endif
                              endfor
                            
                              for vcs in heads
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
                                let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
                                let b:airline_head .= b:buffer_vcs_config[vcs].untracked
                              endfor
                            
                              if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
                              if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
                              if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  'â€¦' : '.')
                                endif
                              endif
                            
                              return b:airline_head

FUNCTION  airline#parts#mode()
Called 25 times
Total time:   0.000839
 Self time:   0.000198

count  total (s)   self (s)
   25   0.000834   0.000193   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>73_add_section()
Called 30 times
Total time:   0.003841
 Self time:   0.001266

count  total (s)   self (s)
   30              0.000204     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   30   0.000614   0.000230     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
   30              0.000042     if condition
                                  call a:builder.add_raw('%(')
                                endif
   30   0.002543   0.000352     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   30              0.000052     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  airline#extensions#quickfix#apply()
Called 3 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    3              0.000013   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  airline#mode_changed()
Called 7 times
Total time:   0.000112
 Self time:   0.000080

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    7              0.000049   let g:airline#visual_active = (mode() =~? '[vs]')
    7   0.000055   0.000023   call airline#update_tabline()

FUNCTION  airline#extensions#wordcount#apply()
Called 3 times
Total time:   0.000159
 Self time:   0.000159

count  total (s)   self (s)
    3              0.000034   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'org', 'rst', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    3              0.000011   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    3              0.000008   if did_filetype()
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? index(filetypes, &filetype) > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
                              endif
                            
    3              0.000012   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
                              endif

FUNCTION  <SNR>75_BlockStart()
Called 5547 times
Total time:   5.014322
 Self time:   5.014322

count  total (s)   self (s)
                                " Note: Make sure to reset cursor position after using this function.
 5547              0.009108     call cursor(a:lnum, 0)
                            
                                " In case the end of the block is indented to a higher level than the def
                                " statement plus one shiftwidth, we need to find the indent level at the
                                " bottom of that if/for/try/while/etc. block.
 5547              4.132390     let last_def = searchpos(s:def_regex, 'bcnW')[0]
 5547              0.004563     if last_def
 5547              0.008736         let last_def_indent = indent(last_def)
 5547              0.007742         call cursor(last_def, 0)
 5547              0.719659         let next_stmt_at_def_indent = searchpos('\v^\s{'.last_def_indent.'}[^[:space:]#]', 'nW')[0]
 5547              0.003144     else
                                    let next_stmt_at_def_indent = -1
                                endif
                            
                                " Now find the class/def one shiftwidth lower than the start of the
                                " aforementioned indent block.
 5547              0.006412     if next_stmt_at_def_indent && next_stmt_at_def_indent < a:lnum
                                    let max_indent = max([indent(next_stmt_at_def_indent) - &shiftwidth, 0])
                                else
 5547              0.018855         let max_indent = max([indent(prevnonblank(a:lnum)) - &shiftwidth, 0])
 5547              0.002422     endif
 5547              0.070163     return searchpos('\v^\s{,'.max_indent.'}(def |class )\w', 'bcnW')[0]

FUNCTION  <SNR>55_is_excluded_window()
Called 5 times
Total time:   0.000413
 Self time:   0.000413

count  total (s)   self (s)
    5              0.000023   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
   20              0.000041   for matchw in g:airline_exclude_filenames
   15              0.000163     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
   15              0.000018   endfor
                            
    5              0.000012   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
    5              0.000010   return 0

FUNCTION  <SNR>69_GetHiCmd()
Called 56 times
Total time:   0.004599
 Self time:   0.004599

count  total (s)   self (s)
                              " a:list needs to have 5 items!
   56              0.000058   let res = ''
   56              0.000062   let i = -1
  336              0.000269   while i < 4
  280              0.000269     let i += 1
  280              0.000551     let item = get(a:list, i, '')
  280              0.000257     if item is ''
   98              0.000088       continue
                                endif
  182              0.000137     if i == 0
   36              0.000077       let res .= ' guifg='.item
   36              0.000028     elseif i == 1
   27              0.000039       let res .= ' guibg='.item
   27              0.000015     elseif i == 2
   56              0.000119       let res .= ' ctermfg='.item
   56              0.000039     elseif i == 3
   49              0.000081       let res .= ' ctermbg='.item
   49              0.000030     elseif i == 4
   14              0.000042       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
   14              0.000006     endif
  182              0.000118   endwhile
   56              0.000056   return res

FUNCTION  airline#statusline()
Called 31 times
Total time:   0.000490
 Self time:   0.000490

count  total (s)   self (s)
   31              0.000226   if has_key(s:contexts, a:winnr)
   31              0.000224     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>45_ResetConcealOption()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000005     if exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet
                                    if exists("b:indentLine_original_concealcursor")
                                        let &l:concealcursor = b:indentLine_original_concealcursor
                                    endif
                                    if exists("b:indentLine_original_conceallevel")
                                        let &l:conceallevel = b:indentLine_original_conceallevel
                                    endif
                                    let b:indentLine_ConcealOptionSet = 0
                                endif

FUNCTION  <SNR>84_GetCounts()
Called 54 times
Total time:   0.000939
 Self time:   0.000366

count  total (s)   self (s)
   54   0.000474   0.000188     if !s:BufferCacheExists(a:buffer)
   54   0.000442   0.000155         return s:CreateCountDict()
                                endif
                            
                                call s:UpdateCacheIfNecessary(a:buffer)
                            
                                return g:ale_buffer_info[a:buffer].count

FUNCTION  <SNR>78_InsideCommentOrStringAndShouldStop()
Called 8 times
Total time:   0.000925
 Self time:   0.000089

count  total (s)   self (s)
    8   0.000866   0.000030   let retval = s:InsideCommentOrString()
    8              0.000012   let inside_comment = retval == 1
    8              0.000006   let inside_string = retval == 2
                            
    8              0.000016   if inside_comment && g:ycm_complete_in_comments || inside_string && g:ycm_complete_in_strings
                                return 0
                              endif
                            
    8              0.000005   return retval

FUNCTION  airline#extensions#apply()
Called 5 times
Total time:   0.000802
 Self time:   0.000389

count  total (s)   self (s)
                            
    5   0.000455   0.000042   if s:is_excluded_window()
                                return -1
                              endif
                            
    5              0.000015   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
    5              0.000013   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                              endif
                            
    5              0.000009   if &previewwindow
    2              0.000004     let w:airline_section_a = 'Preview'
    2              0.000004     let w:airline_section_b = ''
    2              0.000009     let w:airline_section_c = bufname(winbufnr(winnr()))
    2              0.000000   endif
                            
    5              0.000044   if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
    5              0.000027   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  pymode#folding#expr()
Called 5907 times
Total time:   7.091584
 Self time:   0.957751

count  total (s)   self (s)
                            
 5907              0.010562     let line = getline(a:lnum)
 5907              0.007129     let indent = indent(a:lnum)
 5907              0.010583     let prev_line = getline(a:lnum - 1)
 5907              0.008379     let next_line = getline(a:lnum + 1)
                            
                                " Decorators {{{
 5907              0.030662     if line =~ s:decorator_regex
                                    return ">".(indent / &shiftwidth + 1)
                                endif "}}}
                            
                                " Definition {{{
 5907              0.043865     if line =~ s:def_regex
                                    " If indent of this line is greater or equal than line below
                                    " and previous non blank line does not end with : (that is, is not a
                                    " definition)
                                    " Keep the same indentation
                                    if indent(a:lnum) >= indent(a:lnum+1) && getline(prevnonblank(a:lnum)) !~ ':\s*$'
                                        return '='
                                    endif
                                    " Check if last decorator is before the last def
                                    let decorated = 0
                                    let lnum = a:lnum - 1
                                    while lnum > 0
                                        if getline(lnum) =~ s:def_regex
                                            break
                                        elseif getline(lnum) =~ s:decorator_regex
                                            let decorated = 1
                                            break
                                        endif
                                        let lnum -= 1
                                    endwhile
                                    if decorated
                                        return '='
                                    else
                                        return ">".(indent / &shiftwidth + 1)
                                    endif
                                endif "}}}
                            
                                " Docstrings {{{
                            
                                " TODO: A while loop now counts the number of open and closed folding in
                                " order to determine if it is a closing or opening folding.
                                " It is working but looks like it is an overkill.
                            
                                " Notice that an effect of this is that other docstring matches will not
                                " be one liners.
 5907              0.045416     if line =~ s:doc_line_regex
                                    return "="
                                endif
                            
 5907              0.037404     if line =~ s:doc_begin_regex
                                        " echom 'just entering'
  360   0.016056   0.000938         if s:Is_opening_folding(a:lnum)
                                        " echom 'entering at line ' . a:lnum
  120              0.000225             return ">".(indent / &shiftwidth + 1)
                                    endif
  240              0.000075     endif
 5787              0.039154     if line =~ s:doc_end_regex
  240   0.001445   0.000493         if !s:Is_opening_folding(a:lnum)
                                        " echom 'leaving at line ' . a:lnum
  240              0.000468             return "<".(indent / &shiftwidth + 1)
                                    endif
                                endif "}}}
                            
                                " Nested Definitions {{{
                                " Handle nested defs but only for files shorter than
                                " g:pymode_folding_nest_limit lines due to performance concerns
 5547              0.015126     if line('$') < g:pymode_folding_nest_limit && indent(prevnonblank(a:lnum))
 5547              0.008952         let curpos = getpos('.')
 5547              0.002825         try
 5547   5.030769   0.016447             let last_block = s:BlockStart(a:lnum)
 5547              0.010028             let last_block_indent = indent(last_block)
                            
                                        " Check if last class/def is not indented and therefore can't be
                                        " nested.
 5547              0.004117             if last_block_indent
 5547              0.008602                 call cursor(a:lnum, 0)
 5547              0.290297                 let next_def = searchpos(s:def_regex, 'nW')[0]
 5547              0.009609                 let next_def_indent = next_def ? indent(next_def) : -1
 5547   1.118518   0.015077                 let last_block_end = s:BlockEnd(last_block)
                            
                                            " If the next def has greater indent than the previous def, it
                                            " is nested one level deeper and will have its own fold. If
                                            " the class/def containing the current line is on the first
                                            " line it can't be nested, and if this block ends on the last
                                            " line, it contains no trailing code that should not be
                                            " folded. Finally, if the next non-blank line after the end of
                                            " the previous def is less indented than the previous def, it
                                            " is not part of the same fold as that def. Otherwise, we know
                                            " the current line is at the end of a nested def.
 5547              0.023547                 if next_def_indent <= last_block_indent && last_block > 1 && last_block_end < line('$') && indent(nextnonblank(last_block_end)) >= last_block_indent
                            
                                                " Include up to one blank line in the fold
                                                if getline(last_block_end) =~ s:blank_regex
                                                    let fold_end = min([prevnonblank(last_block_end - 1), last_block_end]) + 1
                                                else
                                                    let fold_end = last_block_end
                                                endif
                                                if a:lnum == fold_end
                                                    return 's1'
                                                else
                                                    return '='
                                                endif
                                            endif
 5547              0.002175             endif
 5547              0.003385         finally
 5547              0.009596             call setpos('.', curpos)
 5547              0.002970         endtry
 5547              0.002403     endif " }}}
                            
                                " Blank Line {{{
 5547              0.025912     if line =~ s:blank_regex
  544              0.001618         if prev_line =~ s:blank_regex
  200              0.000602             if indent(a:lnum + 1) == 0 && next_line !~ s:blank_regex && next_line !~ s:doc_general_regex
                                            if s:Is_opening_folding(a:lnum)
                                                " echom a:lnum
                                                return "="
                                            else
                                                " echom "not " . a:lnum
                                                return 0
                                            endif
                                        endif
  200              0.000141             return -1
                                    else
  344              0.000199             return '='
                                    endif
                                endif " }}}
                            
 5003              0.002874     return '='
                            

FUNCTION  youcompleteme#CompleteFunc()
Called 10 times
Total time:   0.000165
 Self time:   0.000165

count  total (s)   self (s)
   10              0.000024   if a:findstart
                                " When auto-wrapping is enabled, Vim wraps the current line after the
                                " completion request is sent but before calling this function. The starting
                                " column returned by the server is invalid in that case and must be
                                " recomputed.
    5              0.000018     if s:completion.line != line( '.' )
                                  " Given
                                  "   scb: column where the completion starts before auto-wrapping
                                  "   cb: cursor column before auto-wrapping
                                  "   sca: column where the completion starts after auto-wrapping
                                  "   ca: cursor column after auto-wrapping
                                  " we have
                                  "   ca - sca = cb - scb
                                  "   sca = scb + ca - cb
                                  let s:completion.completion_start_column += col( '.' ) - s:completion.column
                                endif
    5              0.000019     return s:completion.completion_start_column - 1
                              endif
    5              0.000009   return s:completion.completions

FUNCTION  airline#util#has_lawrencium()
Called 25 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
   25              0.000067   return exists('*lawrencium#statusline')

FUNCTION  airline#highlighter#get_highlight()
Called 561 times
Total time:   0.048949
 Self time:   0.022558

count  total (s)   self (s)
  561              0.005887   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  561              0.001601   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
                              else
  561   0.013880   0.001930     let fg = s:get_syn(a:group, 'fg')
  561   0.012542   0.001726     let bg = s:get_syn(a:group, 'bg')
  561              0.001919     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  561              0.000441     if reverse
                                  let res = s:get_array(bg, fg, bold ? ['bold'] : a:000)
                                else
  561   0.005863   0.002238       let res = s:get_array(fg, bg, bold ? ['bold'] : a:000)
  561              0.000310     endif
  561              0.000242   endif
  561              0.001296   let s:hl_groups[a:group] = res
  561              0.000449   return res

FUNCTION  airline#util#shorten()
Called 75 times
Total time:   0.001653
 Self time:   0.001050

count  total (s)   self (s)
   75   0.000969   0.000366   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return 'â€¦'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'â€¦'
                                endif
                              else
   75              0.000078     return a:text
                              endif

FUNCTION  <SNR>36_addtomrufs()
Called 4 times
Total time:   0.000491
 Self time:   0.000491

count  total (s)   self (s)
    4              0.000083 	let fn = fnamemodify(a:fname, ':p')
    4              0.000033 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    4              0.000266 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
                            	en
    4              0.000036 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    4              0.000006 	if idx
                            		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
                            		cal insert(s:mrufs, fn)
                            		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
                            	en

FUNCTION  <SNR>28_on_cursor_moved()
Called 1 time
Total time:   0.010366
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000009   if winnr() != s:active_winnr
    1   0.010342   0.000013     call s:on_window_changed()
    1              0.000001   endif
    1   0.000013   0.000007   call airline#update_tabline()

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 7 times
Total time:   0.002452
 Self time:   0.000263

count  total (s)   self (s)
    7              0.000032   if getbufvar(a:bufnr, '&modified')
    4              0.000030     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    4              0.000001   else
    3              0.000044     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    3              0.000003   endif
                            
    7              0.000012   if !empty(colors)
    7   0.002269   0.000080     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    7              0.000005   endif

FUNCTION  airline#extensions#branch#get_head()
Called 25 times
Total time:   0.009725
 Self time:   0.000809

count  total (s)   self (s)
   25   0.008375   0.000111   let head = airline#extensions#branch#head()
   25   0.000249   0.000142   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
   25              0.000086   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
   25   0.000668   0.000123   let head = airline#util#shorten(head, winwidth, minwidth)
   25              0.000081   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
   25              0.000076   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   25              0.000157   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  airline#extensions#ctrlp#apply()
Called 3 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
    3              0.000035   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  <SNR>45_InitColor()
Called 1 time
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
    1              0.000002     if !g:indentLine_setColors
                                    return
                                endif
                            
    1              0.000002     let default_term_bg = "NONE"
    1              0.000002     let default_gui_bg  = "NONE"
    1              0.000001     if &background ==# "light"
                                    let default_term_fg = 249
                                    let default_gui_fg = "Grey70"
                                else
    1              0.000002         let default_term_fg = 239
    1              0.000001         let default_gui_fg = "Grey30"
    1              0.000001     endif
                            
    1              0.000002     if g:indentLine_defaultGroup != ""
                                    let default_id = synIDtrans(hlID(g:indentLine_defaultGroup))
                                    let default_term_fg = synIDattr(default_id, "fg", "cterm") == "" ? default_term_fg :  synIDattr(default_id, "fg", "cterm")
                                    let default_term_bg = synIDattr(default_id, "bg", "cterm") == "" ? default_term_bg :  synIDattr(default_id, "bg", "cterm")
                                    let default_gui_fg = synIDattr(default_id, "fg", "gui") == "" ? default_gui_fg :  synIDattr(default_id, "fg", "gui")
                                    let default_gui_bg = synIDattr(default_id, "bg", "gui") == "" ? default_gui_bg :  synIDattr(default_id, "bg", "gui")
                                endif
                            
    1              0.000003     if !exists("g:indentLine_color_term")
    1              0.000002         let term_color = default_term_fg
    1              0.000001     else
                                    let term_color = g:indentLine_color_term
                                endif
                            
    1              0.000002     if !exists("g:indentLine_bgcolor_term")
    1              0.000002         let term_bgcolor = default_term_bg
    1              0.000000     else
                                    let term_bgcolor = g:indentLine_bgcolor_term
                                endif
                            
    1              0.000002     if !exists("g:indentLine_color_gui")
    1              0.000002         let gui_color = default_gui_fg
    1              0.000001     else
                                    let gui_color = g:indentLine_color_gui
                                endif
                            
    1              0.000002     if !exists("g:indentLine_bgcolor_gui")
    1              0.000001         let gui_bgcolor = default_gui_bg
    1              0.000001     else
                                    let gui_bgcolor = g:indentLine_bgcolor_gui
                                endif
                            
    1              0.000017     execute "highlight Conceal cterm=NONE ctermfg=" . term_color . " ctermbg=" . term_bgcolor
    1              0.000014     execute "highlight Conceal gui=NONE guifg=" . gui_color .  " guibg=" . gui_bgcolor
                            
    1              0.000002     if &term ==# "linux"
                                    if &background ==# "light"
                                        let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
                                    else
                                        let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
                                    endif
                                    execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
                                endif

FUNCTION  <SNR>78_AllowedToCompleteInBuffer()
Called 57 times
Total time:   0.002343
 Self time:   0.002087

count  total (s)   self (s)
   57              0.000291   let buffer_filetype = getbufvar( a:buffer, '&filetype' )
                            
   57              0.000283   if empty( buffer_filetype ) || getbufvar( a:buffer, '&buftype' ) ==# 'nofile' || buffer_filetype ==# 'qf'
    2              0.000005     return 0
                              endif
                            
   55   0.000444   0.000188   if s:DisableOnLargeFile( a:buffer )
                                return 0
                              endif
                            
   55              0.000392   let whitelist_allows = type( g:ycm_filetype_whitelist ) != type( {} ) || has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, buffer_filetype )
   55              0.000244   let blacklist_allows = type( g:ycm_filetype_blacklist ) != type( {} ) || !has_key( g:ycm_filetype_blacklist, buffer_filetype )
                            
   55              0.000091   let allowed = whitelist_allows && blacklist_allows
   55              0.000041   if allowed
   55              0.000162     let s:previous_allowed_buffer_number = bufnr( a:buffer )
   55              0.000031   endif
   55              0.000049   return allowed

FUNCTION  <SNR>61_update_branch()
Called 25 times
Total time:   0.005572
 Self time:   0.001252

count  total (s)   self (s)
   75              0.000163   for vcs in keys(s:vcs_config)
   50   0.004693   0.000373     call {s:vcs_config[vcs].update_branch}()
   50              0.000198     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
                                endif
   50              0.000046   endfor

FUNCTION  <SNR>69_CheckDefined()
Called 307 times
Total time:   0.006320
 Self time:   0.006320

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  307              0.000763   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  307              0.000791   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
  565              0.000707   for val in a:colors
  565              0.000981     if !empty(val) && val !=# 'NONE'
  307              0.000330       return a:colors
                                endif
  258              0.000169   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>28_init()
Called 3 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    3              0.000010   if s:airline_initialized
    3              0.000007     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  if g:airline_theme is# 'random'
                                    let g:airline_theme=s:random_theme()
                                  endif
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  call airline#util#warning(printf('Could not resolve airline theme "%s". Themes have been migrated to github.com/vim-airline/vim-airline-themes.', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              call airline#util#doautocmd('AirlineAfterInit')

FUNCTION  airline#util#prepend()
Called 62 times
Total time:   0.000394
 Self time:   0.000394

count  total (s)   self (s)
   62              0.000109   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
   62              0.000192   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>78_CloseCompletionMenu()
Called 39 times
Total time:   0.000180
 Self time:   0.000156

count  total (s)   self (s)
   39              0.000053   if pumvisible()
    2   0.000045   0.000021     call s:SendKeys( "\<C-e>" )
    2              0.000002   endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 1 time
Total time:   0.000066
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000003     let l:buffer = bufnr('')
                            
    1              0.000002     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    1              0.000003     if mode(1) isnot# 'n'
                                    return
                                endif
                            
    1   0.000015   0.000008     call s:StopCursorTimer()
                            
    1              0.000005     let l:pos = getpos('.')[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
    1              0.000002     if l:pos != s:last_pos
    1   0.000020   0.000007         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
    1              0.000002         let s:last_pos = l:pos
    1              0.000005         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
    1              0.000001     endif

FUNCTION  <SNR>78_OnBlankLine()
Called 8 times
Total time:   0.000339
 Self time:   0.000038

count  total (s)   self (s)
    8   0.000338   0.000037   return s:Pyeval( 'not vim.current.line or vim.current.line.isspace()' )

FUNCTION  airline#extensions#ale#get_warning()
Called 27 times
Total time:   0.003151
 Self time:   0.000148

count  total (s)   self (s)
   27   0.003143   0.000140   return airline#extensions#ale#get('warning')

FUNCTION  airline#builder#new()
Called 5 times
Total time:   0.000207
 Self time:   0.000207

count  total (s)   self (s)
    5              0.000061   let builder = copy(s:prototype)
    5              0.000022   let builder._context = a:context
    5              0.000013   let builder._sections = []
                            
    5              0.000089   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    5              0.000011   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
 5907   7.091584   0.957751  pymode#folding#expr()
 5547   5.014322             <SNR>75_BlockStart()
 5547   1.103441             <SNR>75_BlockEnd()
   31   0.085191   0.003208  airline#check_mode()
    7   0.079156   0.013059  airline#highlighter#highlight()
  307   0.053124   0.013377  airline#highlighter#exec()
  561   0.048949   0.022558  airline#highlighter#get_highlight()
  114   0.038909   0.003027  <SNR>69_exec_separator()
    1   0.032450   0.000153  pymode#rope#complete_on_dot()
    1   0.032297   0.025723  pymode#rope#complete()
   11   0.030547   0.000696  <SNR>28_on_window_changed()
    3   0.029828   0.000326  airline#update_statusline()
    5   0.029140   0.000304  <SNR>57_invoke_funcrefs()
 1122   0.022766             <SNR>69_get_syn()
    5   0.021168   0.003944  12()
  210   0.018368   0.001022  airline#themes#get_highlight()
  600   0.016070             <SNR>75_Is_opening_folding()
    8   0.014768   0.000658  <SNR>78_OnTextChangedInsertMode()
    5   0.014329   0.007739  <SNR>78_OnInsertLeave()
   22   0.011469   0.000266  <SNR>72_get_seperator()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 5547              5.014322  <SNR>75_BlockStart()
 5547              1.103441  <SNR>75_BlockEnd()
 5907   7.091584   0.957751  pymode#folding#expr()
    1   0.032297   0.025723  pymode#rope#complete()
 1122              0.022766  <SNR>69_get_syn()
  561   0.048949   0.022558  airline#highlighter#get_highlight()
  600              0.016070  <SNR>75_Is_opening_folding()
  307   0.053124   0.013377  airline#highlighter#exec()
    7   0.079156   0.013059  airline#highlighter#highlight()
    5   0.014329   0.007739  <SNR>78_OnInsertLeave()
    1   0.006574   0.006571  pymode#wide_message()
  307              0.006320  <SNR>69_CheckDefined()
   75              0.006188  <SNR>78_Pyeval()
    8   0.006886   0.006173  <SNR>78_IdentifierFinishedOperations()
    5   0.006159   0.005493  <SNR>78_OnFileReadyToParse()
    2              0.005143  <SNR>89_SearchParensPair()
    4   0.005198   0.004844  <SNR>78_InvokeCompletion()
   56              0.004599  <SNR>69_GetHiCmd()
    5   0.021168   0.003944  12()
  561              0.003625  <SNR>69_get_array()

